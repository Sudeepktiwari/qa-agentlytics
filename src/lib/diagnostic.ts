import OpenAI from "openai";
import { getDb } from "./mongo";
import { querySimilarChunks } from "./chroma";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function generateCompleteDiagnosticData(
  label: string,
  workflow: string,
  context: string,
  businessName?: string,
): Promise<{
  diagnostic_answer: string;
  diagnostic_options: string[];
  diagnostic_option_details: { label: string; answer: string }[];
}> {
  try {
    const prompt = `
SYSTEM:
You are an expert consultant and AI system architect. You need to provide a complete diagnostic analysis for a user selection.

TASK:
1. Generate a diagnostic insight (Answer) based on the user's selection.
2. Generate 3-4 follow-up options based on that insight.
3. Generate detailed "Recommended Actions" explanations for each option.

INPUT:
Label: ${label}
Workflow: ${workflow}
Business Name: ${businessName || "Not provided"}
Context: ${context}

RULES FOR DIAGNOSTIC ANSWER:
- Tone: Professional, consultative, value-driven.
- Workflow Templates:
  - validation_path: Validate strong position. Suggest scaling. Focus on "what's next".
  - optimization_workflow: Acknowledge friction. Explain business impact (lost revenue/efficiency). State how platform resolves it.
  - diagnostic_education: Address visibility gap. Explain why data is critical. Explain platform intelligence.
  - sales_alert: Address high stakes. Explain cost of inaction. Explain risk mitigation.
- Length: 2-3 sentences.
- If "businessName" is provided, use it instead of generic terms.

RULES FOR OPTIONS:
- Generate 3-4 short, value-driven options (max 5 words each).
- Must map to specific outcomes, levers, or capabilities mentioned in the answer.
- NO generic CTAs (Book Call, View Case Study, Contact Sales).

RULES FOR OPTION DETAILS:
- For EACH option generated above, write a mechanism-driven narrative (8-14 lines).
- Structure:
  1. Positioning contrast ("Traditional tools react, this system...")
  2. Behavioral signals monitored (pricing dwell, comparison loops, etc.)
  3. Thresholds/readiness modeling determine activation
  4. Contextual intervention trigger
  5. Business outcome tied to conversion stability/lead capture
- Tone: Professional, authoritative. No hype words.

OUTPUT FORMAT (JSON):
{
  "diagnostic_answer": "string",
  "diagnostic_options": ["string", "string", "string"],
  "diagnostic_option_details": [
    { "label": "exact option string", "answer": "narrative explanation" }
  ]
}`;

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      response_format: { type: "json_object" },
      messages: [{ role: "user", content: prompt }],
      temperature: 0.3,
    });

    const content = response.choices[0]?.message?.content || "{}";
    const data = JSON.parse(content);

    return {
      diagnostic_answer:
        typeof data.diagnostic_answer === "string"
          ? data.diagnostic_answer
          : "",
      diagnostic_options: Array.isArray(data.diagnostic_options)
        ? data.diagnostic_options.filter(
            (o: any) => typeof o === "string" && o.trim().length,
          )
        : [],
      diagnostic_option_details: Array.isArray(data.diagnostic_option_details)
        ? data.diagnostic_option_details.filter(
            (o: any) =>
              o &&
              typeof o.label === "string" &&
              typeof o.answer === "string" &&
              o.label &&
              o.answer,
          )
        : [],
    };
  } catch (e) {
    console.error("Error generating complete diagnostic data:", e);
    return {
      diagnostic_answer: "",
      diagnostic_options: [],
      diagnostic_option_details: [],
    };
  }
}

export async function autoGenerateDiagnosticAnswers(
  adminId: string,
  filterUrl?: string,
) {
  console.log(
    `[Diagnostic] Starting post-crawl generation for ${adminId}${
      filterUrl ? ` (URL: ${filterUrl})` : ""
    }...`,
  );
  try {
    const db = await getDb();
    const summariesCollection = db.collection("structured_summaries");

    // 1. Fetch summaries (filter by URL if provided)
    const query: any = { adminId };
    if (filterUrl) {
      query.url = filterUrl;
    }
    const summaries = await summariesCollection.find(query).toArray();
    if (!summaries.length) {
      console.log(
        `[Diagnostic] No structured summaries found for ${adminId}${
          filterUrl ? ` matching ${filterUrl}` : ""
        }`,
      );
      return;
    }

    // 2. Collect all options
    let businessName: string | undefined;
    const allOptionsMap = new Map<
      string,
      { label: string; workflow: string }
    >();
    summaries.forEach((s) => {
      if (!businessName && s.structuredSummary?.businessName) {
        businessName = s.structuredSummary.businessName;
      }
      s.structuredSummary?.sections?.forEach((sec: any) => {
        [...(sec.leadQuestions || []), ...(sec.salesQuestions || [])].forEach(
          (q: any) => {
            q.options?.forEach((o: any) => {
              if (o.label && o.workflow) {
                const key = `${o.label}::${o.workflow}`;
                // Only add to processing list if not already processed in this run
                if (!allOptionsMap.has(key)) {
                  allOptionsMap.set(key, {
                    label: o.label,
                    workflow: o.workflow,
                  });
                }
              }
            });
          },
        );
      });
    });

    const uniqueOptions = Array.from(allOptionsMap.values());
    console.log(
      `[Diagnostic] Found ${uniqueOptions.length} unique options to process for ${adminId}.`,
    );

    // 3. Process with concurrency (Batch of 5)
    const results = new Map<
      string,
      {
        answer: string;
        options: string[];
        optionDetails?: { label: string; answer: string }[];
      }
    >();

    const processOption = async (opt: { label: string; workflow: string }) => {
      try {
        // A. Get Embedding for the option label to find relevant content
        const embResp = await openai.embeddings.create({
          model: "text-embedding-3-small",
          input: opt.label,
          dimensions: 1024,
        });
        const vector = embResp.data[0].embedding;

        // B. Get Context from vector DB
        const chunks = await querySimilarChunks(vector, 3, adminId);
        const contextText = chunks.map((c) => c.text).join("\n---\n");

        // C. Generate Answer using strict template
        const result = await generateSingleDiagnosticAnswer(
          opt.label,
          opt.workflow,
          contextText,
          businessName,
        );

        if (!result.options || result.options.length === 0) {
          console.warn(
            `[Diagnostic] Warning: No options generated for ${opt.label}. Leaving diagnostic_options empty.`,
          );
        }

        results.set(`${opt.label}::${opt.workflow}`, result);
      } catch (e) {
        console.error(`Error processing option ${opt.label}:`, e);
      }
    };

    // Run in batches
    const BATCH_SIZE = 5;
    for (let i = 0; i < uniqueOptions.length; i += BATCH_SIZE) {
      const batch = uniqueOptions.slice(i, i + BATCH_SIZE);
      await Promise.all(batch.map(processOption));
      console.log(
        `[Diagnostic] Processed ${Math.min(i + BATCH_SIZE, uniqueOptions.length)}/${uniqueOptions.length}`,
      );
    }

    // 4. Update Database
    let updatedCount = 0;
    for (const summary of summaries) {
      let modified = false;
      const sections = summary.structuredSummary?.sections;
      if (!sections) continue;

      sections.forEach((sec: any) => {
        [...(sec.leadQuestions || []), ...(sec.salesQuestions || [])].forEach(
          (q: any) => {
            q.options?.forEach((o: any) => {
              const key = `${o.label}::${o.workflow}`;
              if (results.has(key)) {
                const res = results.get(key);
                if (res) {
                  // Always update if we have a result
                  o.diagnostic_answer = res.answer;
                  o.diagnostic_options = res.options;
                  if (res.optionDetails && res.optionDetails.length > 0) {
                    o.diagnostic_option_details = res.optionDetails;
                  }
                  modified = true;
                }
              }
            });
          },
        );
      });

      if (modified) {
        await summariesCollection.updateOne(
          { _id: summary._id },
          {
            $set: {
              "structuredSummary.sections": sections,
              diagnosticGeneratedAt: new Date(),
            },
          },
        );
        updatedCount++;
      }
    }
    console.log(
      `[Diagnostic] Completed updates for ${updatedCount} summaries.`,
    );
  } catch (err) {
    console.error("[Diagnostic] Critical error in post-crawl generation:", err);
  }
}

export async function generateSingleDiagnosticAnswer(
  label: string,
  workflow: string,
  context: string,
  businessName?: string,
): Promise<{
  answer: string;
  options: string[];
  optionDetails?: { label: string; answer: string }[];
}> {
  try {
    const result = await generateCompleteDiagnosticData(
      label,
      workflow,
      context,
      businessName,
    );

    return {
      answer: result.diagnostic_answer,
      options: result.diagnostic_options,
      optionDetails: result.diagnostic_option_details,
    };
  } catch (e) {
    console.error("Error generating single diagnostic answer:", e);
    return { answer: "", options: [] };
  }
}
